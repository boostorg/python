<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0//EN"
"http://www.w3.org/TR/REC-html40/strict.dtd">
    <title>
      Inheritance
    </title>
    <div>
      <h1>
         <img width="277" height="86" id="_x0000_i1025" align="center"
        src="../../../c++boost.gif" alt= "c++boost.gif (8819 bytes)">Inheritance
      </h1>

<h2>Inheritance in Python</h2>

      <p>
         Boost.Python extension classes support single and multiple-inheritance in
         Python, just like regular Python classes. You can arbitrarily mix
         built-in Python classes with extension classes in a derived class'
         tuple of bases. Whenever a Boost.Python extension class is among the bases for a
         new class in Python, the result is an extension class:
<blockquote>
<pre>
&gt;&gt;&gt; class MyPythonClass:
...     def f(): return 'MyPythonClass.f()'
...
&gt;&gt;&gt; import my_extension_module
&gt;&gt;&gt; class Derived(my_extension_module.MyExtensionClass, MyPythonClass):
...     '''This is an extension class'''
...     pass
...
&gt;&gt;&gt; x = Derived()
&gt;&gt;&gt; x.f()
'MyPythonClass.f()'
&gt;&gt;&gt; x.g()
'MyExtensionClass.g()'
</pre>
</blockquote>

<h2><a name="implicit_conversion">Reflecting C++ Inheritance Relationships</a></h2>
      <p>
        Boost.Python also allows us to represent C++ inheritance relationships so that
        wrapped derived classes may be passed where values, pointers, or
        references to a base class are expected as arguments. The
        <code>declare_base</code> member function of
        <code>class_builder&lt;&gt;</code> is used to establish the relationship
        between base and derived classes:

<blockquote>
<pre>
#include &lt;memory&gt; // for std::auto_ptr&lt;&gt;

struct Base {
    virtual ~Base() {}
    virtual const char* name() const { return "Base"; }
};

struct Derived : Base {
    Derived() : x(-1) {}
    virtual const char* name() const { return "Derived"; }
    int x;
};

std::auto_ptr&lt;Base&gt; derived_as_base() {
    return std::auto_ptr&lt;Base&gt;(new Derived);
}

const char* get_name(const Base& b) {
    return b.name();
}

int get_derived_x(const Derived& d) {
    return d.x;
}
    <hr>
#include &lt;boost/python/class_builder.hpp&gt;

// namespace alias for code brevity
namespace python = boost::python;

BOOST_PYTHON_MODULE_INIT(my_module)
{
    python::module_builder my_module("my_module");                            
                                                                              
    python::class_builder&lt;Base&gt; base_class(my_module, "Base");          
    base_class.def(python::constructor&lt;&gt;());                        
                                                                              
    python::class_builder&lt;Derived&gt; derived_class(my_module, "Derived"); 
    derived_class.def(python::constructor&lt;&gt;());                     
    <b>// Establish the inheritance relationship between Base and Derived     
    derived_class.declare_base(base_class);</b>                               
                                                                              
    my_module.def(derived_as_base, "derived_as_base");                        
    my_module.def(get_name, "get_name");                                      
    my_module.def(get_derived_x, "get_derived_x"); 
}
</pre>
</blockquote>

<p>
   Then, in Python:
<blockquote>
<pre>
&gt;&gt;&gt; from my_module import *
&gt;&gt;&gt; base = Base()
&gt;&gt;&gt; derived = Derived()
&gt;&gt;&gt; get_name(base)
'Base'
</pre>
</blockquote>
<i>objects of wrapped class Derived may be passed where Base is expected</i>
<blockquote>
<pre>
&gt;&gt;&gt; get_name(derived) 
'Derived'
</pre>
</blockquote>
<i>objects of wrapped class Derived can be passed where Derived is 
expected but where type information has been lost.</i>
<blockquote>
<pre>
&gt;&gt;&gt; get_derived_x(derived_as_base()) 
-1
</pre>
</blockquote>

<h2>Inheritance Without Virtual Functions</h2>

<p>
  If for some reason your base class has no virtual functions but you still want
  to represent the inheritance relationship between base and derived classes,
  pass the special symbol <code>boost::python::without_downcast</code> as the 2nd parameter
  to <code>declare_base</code>:

<blockquote>
<pre>
struct Base2 {};
struct Derived2 { int f(); };
<hr>
   ...
   python::class_builder&lt;Base&gt; base2_class(my_module, "Base2");
   base2_class.def(python::constructor&lt;&gt;());

   python::class_builder&lt;Derived2&gt; derived2_class(my_module, "Derived2");
   derived2_class.def(python::constructor&lt;&gt;());
   derived_class.declare_base(base_class, <b>python::without_downcast</b>);
</pre>
</blockquote>

<p>This approach will allow <code>Derived2</code> objects to be passed where
 <code>Base2</code> is expected, but does not attempt to implicitly convert (downcast)
 smart-pointers to <code>Base2</code> into <code>Derived2</code> pointers,
 references, or values.

      <p>
         Next: <a href="special.html">Special Method and Operator Support</a>
         Previous: <a href="overloading.html">Function Overloading</a>
         Up: <a href="index.html">Top</a>
      <p>
         &copy; Copyright David Abrahams 2000. Permission to copy, use, modify,
        sell and distribute this document is granted provided this copyright
        notice appears in all copies. This document is provided "as is" without
        express or implied warranty, and with no claim as to its suitability
        for any purpose.
      <p>
         Updated: Nov 26, 2000
    </div>

