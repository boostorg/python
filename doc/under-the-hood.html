<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN">
    <meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
    <title>
      A Peek Under the Hood
    </title>
    <h1>
      <img src="../../../c++boost.gif" alt="c++boost.gif (8819 bytes)" align="center"
      width="277" height="86">
    </h1>
    <h1>
      A Peek Under the Hood
    </h1>
    <p>
      Declaring a <code>class_builder&lt;T&gt;</code> causes the instantiation
      of an <code>extension_class&lt;T&gt;</code> to which it forwards all
      member function calls and which is doing most of the real work.
      <code>extension_class&lt;T&gt;</code> is a subclass of <code>
      PyTypeObject</code>, the <code> struct</code> which Python's 'C' API uses
      to describe a type. <a href="example1.html#world_class">An instance of the
      <code>extension_class&lt;&gt;</code></a> becomes the Python type object
      corresponding to <code>hello::world</code>. When we <a href=
      "example1.html#add_world_class">add it to the module</a> it goes into the
      module's dictionary to be looked up under the name "world".
    <p>
      Boost.Python uses C++'s template argument deduction mechanism to determine the
      types of arguments to functions (except constructors, for which we must
      <a href="example1.html#Constructor_example">provide an argument list</a>
      because they can't be named in C++). Then, it calls the appropriate
      overloaded functions <code>PyObject*
      to_python(boost::python::semantics, </code><em>S</em><code>)</code> and <em>
      S'</em><code>from_python(PyObject*,
      type&lt;</code><em>S</em><code>&gt;)</code> which convert between any C++
      type <em>S</em> and a <code>PyObject*</code>, the type which represents a
      reference to any Python object in its 'C' API. The <a href= 
      "example1.html#world_class"><code>extension_class&lt;T&gt;</code></a>
      template defines a whole raft of these conversions (for <code>T, T*,
      T&amp;, std::auto_ptr&lt;T&gt;</code>, etc.), using the same inline
      friend function technique employed by <a href= 
      "http://www.boost.org/libs/utility/operators.htm">the boost operators
      library</a>.
    <p>
      Because the <code>to_python</code> and <code>from_python</code> functions
      for a user-defined class are defined by <code>
      extension_class&lt;T&gt;</code>, it is important that an instantiation of
      <code> extension_class&lt;T&gt;</code> is visible to any code which wraps
      a C++ function with a <code>T, T*, const T&amp;</code>, etc. parameter or
      return value. In particular, you may want to create all of the classes at
      the top of your module's init function, then <code>def</code> the member
      functions later to avoid problems with inter-class dependencies.
    <p>
      Next: <a href="building.html">Building a Module with Boost.Python</a>
      Previous: <a href="special.html">Special Method and Operator Support</a>
      Up: <a href="index.html">Top</a>
    <p>
      &copy; Copyright David Abrahams 2000. Permission to copy, use, modify,
      sell and distribute this document is granted provided this copyright
      notice appears in all copies. This document is provided "as is" without
      express or implied warranty, and with no claim as to its suitability for
      any purpose.
    <p>
      Updated: Nov 26, 2000

